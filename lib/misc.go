package pitchfork

import (
	"bytes"
	"crypto/sha256"
	"errors"
	"fmt"
	val "github.com/asaskevich/govalidator"
	"github.com/disintegration/imaging"
	"image"
	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"syscall"
	"time"
)

// LogLocation determines if we log locations. Code-level debug option.
var LogLocation = false

// where_strippath strips the path returned by Where()
// to a minimum so that log lines remain short and mostly unique.
//
// This is used to avoid overly long debug code paths in debug messages.
//
// The path is the path leading towards the source code file.
//
// The workdir is the current working directory, typically where
// a developer has source code checked out.
//
// The gopath is the value of the GOPATH environment path where gocode is stored.
//
// Effectively the code removes the workdir or the gopath/src from the provided path.
// This thus leaves either the developer's source directory or the hostname + packagename.
func where_strippath(path string, workdir string, gopath string) (strippedpath string) {
	wl := len(workdir)
	fl := len(path)

	/* If the prefix matches, remove it, to lessen output */
	if wl > 1 && fl > (wl+1) && workdir == path[0:wl] {
		path = path[wl+1:]
	} else {
		/* Shrink too when in GOPATH */
		gp := filepath.Join(gopath, "src")
		gl := len(gp)

		if fl > (gl+1) && gp == path[0:gl] {
			path = path[gl+1:]
		}
	}

	return path
}

// Where returns the string representation of where the
// code currently is (returns file + line number)
//
// The off parameter can be used to provide an offset into the stack.
// This is useful for the case where it is known that the caller of
// the Where function is already called by another function.
// Thus avoiding the reporting of an intermediary function instead
// of the location one would really want to see.
//
// <autogenerated> hops in the stack, which are inserted due
// to golang interface wrappers, are unrolled so that the actual
// location of the source code is returned.
//
// It uses where_strippath to clean the path and keep it
// as short as possible.
//
// The Where function is primarily used for debug output.
func Where(off int) string {
	file := "<autogenerated>"
	line := 0

	/* Unwrap interfaces, they show up as "<autogenerated>" */
	for n := 1; file == "<autogenerated>"; n++ {
		_, file, line, _ = runtime.Caller(n + off)
	}

	/* Get work directory (where we where started from) */
	wd, _ := os.Getwd()
	gopath := os.Getenv("GOPATH")

	/* Strip the path where possible */
	file = where_strippath(file, wd, gopath)

	return file + ":" + strconv.Itoa(line)
}

// LogLoc returns the Where path's location.
//
// LogLoc, short for LogLocation, is used to include
// the Where path for logging purposes.
func LogLoc(off int, pfx string) string {
	if !LogLocation {
		if pfx != "" {
			return pfx + ": "
		}
		return ""
	}

	s := ""

	if pfx != "" {
		s += pfx + "("
	}

	s += Where(2 + off)

	if pfx != "" {
		s += ") "
	} else {
		s += " "
	}

	return s
}

// OutEsc encodes non-ASCII chars in URL-encoded format.
//
// This to make sure control-codes etc do not end up in output.
//
// We encode in URL-encoded format, but we do not escape HTML chars
// anything rendering those should handle that part properly.
//
// Note: this might not be exactly unicode friendly.
func OutEsc(str string) (nstr string) {
	nstr = ""
	for i := 0; i < len(str); i++ {
		c := str[i]

		/* Anything outside of space ' ' to tilde '~' + '%' itself */
		if c < 32 || c > 126 || c == '%' {
			nstr += "%"
			nstr += string("0123456789ABCDEF"[c>>4])
			nstr += string("0123456789ABCDEF"[c&15])
		} else {
			nstr += string(c)
		}
	}
	return
}

// outf is used to output a string to the log output.
//
// One reason this exists is because standard golang log functions just ignore errors...
// thus do our own so that we know when logging fails.
//
// Failed log messags are printed to standard out, which would indeed
// in the case of a daemon still end up in /dev/null. But in debug mode
// one typically does not run the daemon in the background and would
// thus at least have a chance of seeing these messages.
func outf(format string, a ...interface{}) {
	str := fmt.Sprintf(format, a...)

	/* Escape odd chars */
	str = OutEsc(str)

	err := log.Output(2, str)
	if err != nil {
		/* Not really anything else we can do actually */
		fmt.Printf("Logging error '%s' for message: %s", err.Error(), str)
	}
}

// Logging - centralized and to avoid importing log everywhere.
// TODO: Might extend this with extra params to make per-context tracing possible.

// ErrA logs an error message with variable arguments and formatting them, specifying an offset for the where location.
func ErrA(off int, format string, a ...interface{}) {
	outf(LogLoc(1+off, "Error")+format, a...)
}

// Err logs a error message as a pure string
func Err(message string) {
	ErrA(1, "%s", message)
}

// Errf logs an error message with variable arguments and formatting them.
func Errf(format string, a ...interface{}) {
	ErrA(1, format, a...)
}

// LogA logs a message with variable arguments and formatting them, specifying an offset for the where location.
func LogA(off int, format string, a ...interface{}) {
	outf(LogLoc(1+off, "")+format, a...)
}

// Log logs a message as a pure string.
func Log(message string) {
	LogA(1, "%s", message)
}

// Logf logs an error message with variable arguments and formatting them.
func Logf(format string, a ...interface{}) {
	LogA(1, format, a...)
}

// DbgA formats a debug level log message.
//
// Debug output only happens when the Debug flag is enabled.
//
// The function logs the filename, shorted using the Where function,
// and the line number in that file, along with the function name.
// The formatted message is concatenated behind that.
//
// The offset is used to indicate that offset hops should
// be ignored in the stack, this to skip over the debug
// code and thus be able to report the real caller.
func DbgA(off int, format string, a ...interface{}) {
	if !Debug {
		return
	}

	where := Where(1 + off)

	pc := make([]uintptr, 10+off)
	runtime.Callers(2+off, pc)
	f := runtime.FuncForPC(pc[0])

	outf("Debug("+where+") "+f.Name()+" "+format, a...)
}

// Dbg logs a debug message as a pure string.
//
// DbgA details what is further logged.
func Dbg(message string) {
	DbgA(1, message)
}

// Dbgf logs a debug message accepting formatting.
//
// DbgA details what is further logged.
func Dbgf(format string, a ...interface{}) {
	DbgA(1, format, a...)
}

// IsTrue returns a boolean indicating whether the
// string was true or false; it defaults to false
// if the string is not known to be a variant of true.
//
// Recognized as true are the world: 'yes', 'false' and 'on'.
//
// Both uppercase and lowercase variants are supported.
func IsTrue(val string) (b bool) {
	val = strings.ToLower(val)

	if val == "yes" || val == "true" || val == "on" {
		b = true
	} else {
		b = false
	}

	return b
}

// YesNo returns a textual yes/no depending if the input was true or false
func YesNo(b bool) (val string) {
	if b == true {
		return "yes"
	}

	return "no"
}

// NormalizeBoolean returns yes or no depending on the input being a variety of yes/true/on or no/false/off.
//
// It uses IsTrue and then YesNo to normalize the string, see those functions for more details.
func NormalizeBoolean(val string) string {
	return YesNo(IsTrue(val))
}

// SplitArgs splits a string into components obeying quoting.
//
// Given a string str it splits the string into pieces that are returned
// but it allows quotes to surround parts.
//
// This is effectively the same behavior as most UNIX shells.
func SplitArgs(str string) (args []string) {
	r := regexp.MustCompile("'.+'|\".+\"|\\S+")
	return r.FindAllString(str, -1)
}

// Daemon replicates the daemon(2) system call causing the goprocess to run in the background
//
// The process is forked using fork(2).
// Umask is forced to 0.
// setsid(2) is usd to create a new session process group.
// Optionally (nochdir flag being non-zero) the working directory is changed to the root (/).
// Optionally (noclose flag being non-zero) the standard input/output/error file handles
// are closed.
//
// After calling Daemon the parent process will have exit'ed.
// The child process will continue on to run the rest of the go program.
//
// Note that the use of syscalls and forking is not fully supported under Golang
// but it has proven to work without issues over the last several years.
func Daemon(nochdir int, noclose int) (err error) {
	var ret uintptr
	var ret2 uintptr
	var serr syscall.Errno

	/* Already a daemon? */
	if syscall.Getppid() == 1 {
		return nil
	}

	/* Fork off the parent process */
	ret, ret2, serr = syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)
	if serr != 0 {
		return errors.New("fork() failed")
	}

	/* Fork failure */
	if ret2 < 0 {
		os.Exit(-1)
	}

	/* If we got a good PID, then we call exit the parent process */
	if ret > 0 {
		os.Exit(0)
	}

	/* Change the file mode mask */
	_ = syscall.Umask(0)

	/* Create a new SID for the child process */
	_, err = syscall.Setsid()
	if err != nil {
		return errors.New("Error: syscall.Setsid errno: " + err.Error())
	}

	if nochdir == 0 {
		os.Chdir("/")
	}

	if noclose == 0 {
		f, e := os.OpenFile(os.DevNull, os.O_RDWR, 0)
		if e == nil {
			fd := int(f.Fd())
			syscall.Dup2(int(fd), int(os.Stdin.Fd()))
			syscall.Dup2(int(fd), int(os.Stdout.Fd()))
			syscall.Dup2(int(fd), int(os.Stderr.Fd()))
		}
	}

	return nil
}

// SetUID changes the system's User and Groups ID, thus giving up on previous privileges
//
// SetUID effectively calls the setuid(2) and setgid(2) calls.
//
// This is to be run together with the Daemon process to drop privileges when the
// daemon was originally started as the root (uid = 0) user.
func SetUID(username string) (err error) {
	var u *user.User
	var uid int
	var gid int

	u, err = user.Lookup(username)
	if err != nil {
		return err
	}

	uid, err = strconv.Atoi(u.Uid)
	gid, err = strconv.Atoi(u.Gid)

	if gid != 0 {
		if err := syscall.Setgid(gid); err != nil {
			log.Fatalf("failed to Setgid(%d): %v", gid, err)
		}
	}

	if uid != 0 {
		if err := syscall.Setuid(uid); err != nil {
			log.Fatalf("failed to Setuid(%d): %v", uid, err)
		}
	}

	return nil
}

// GetPID returns the Process ID (PID) of the current process.
//
// It uses the getpid(2) call to do this and is primarily a wrapper for that call.
func GetPID() (pid string) {
	return strconv.Itoa(syscall.Getpid())
}

// StorePID stores a PID into a file named filename.
func StorePID(filename string, pid string) {
	err := ioutil.WriteFile(filename, []byte(pid), 0644)
	if err != nil {
		log.Println("Failed to store PID in " + filename + ": " + err.Error())
	}
}

// SortKeys sorts a map of strings indexed by strings into an array of strings.
//
// It returns an array of keys, that are sorted, which then can be used as
// a sorted index into the table that was passed in.
func SortKeys(tbl map[string]string) (keys []string) {
	for k := range tbl {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return
}

// Hex converts a sequence of bytes into a human readable Hex string.
//
// This is primarily a convience function for readability.
func Hex(data []byte) string {
	return fmt.Sprintf("%x", data)
}

// HashIt SHA256-hashes the input string.
//
// The result is returned as a Hex-encoded string.
func HashIt(input string) (hash string) {
	h := sha256.New()
	h.Write([]byte(input))
	return Hex(h.Sum(nil))
}

// Fullname_to_ident creates a username from a fullname.
//
// Examples of conversion:
//  Ben April     -> benapril4125
//  Jeroen Massar -> jeroenmassar1242
//  Joe St'Sauver -> joestsauver7346
//  Eric Ziegast  -> ericziegast3734
func Fullname_to_ident(name string) (out string, err error) {
	/* Force lower case */
	out = strings.ToLower(name)

	/* Only pay attention to the letters in the name */
	validID := regexp.MustCompile(`[^a-z]+`)
	out = validID.ReplaceAllLiteralString(out, "")

	/* Append a random number */
	out += strconv.Itoa(Rand_number(8999) + 1000)

	/* Verify it */
	out, err = Chk_ident("UserName", out)
	return
}

// Chk_ident verifies if a given input string matches our Username_regexp rules.
func Chk_ident(name string, in string) (out string, err error) {
	/* Require something at least */
	if in == "" {
		err = errors.New("No " + name + " provided (empty)")
		return
	}

	/* Force lower case */
	out = strings.ToLower(in)

	ok, err := regexp.MatchString(Config.Username_regexp, out)

	if !ok {
		err = errors.New("Invalid characters in " + name + ", only " + Config.Username_regexp + " are allowed")
		return
	}

	/* All okay and filtered */
	return
}

// Chk_email can be used to check validity of the format of an email address.
func Chk_email(address string) bool {
	return val.IsEmail(address)
}

// Image_resize resizes an image from a file reader to the given dimensions
// and re-encodes it as a PNG.
//
// The maxsize parameter is specified as height 'x' width, eg '123x456'.
//
// The resizing takes care of possible embedded stego and also ensures
// that the image is the size we want it in.
// The re-encoding as PNG ensures that the image data does not contain
// nefarious instructions from the original image.
func Image_resize(file io.Reader, maxsize string) (bits []byte, err error) {
	var im image.Image

	s := strings.SplitN(maxsize, "x", 2)
	max_w, _ := strconv.Atoi(s[0])
	max_h, _ := strconv.Atoi(s[1])

	im, _, err = image.Decode(file)
	if err != nil {
		return
	}

	/* Fit it in the box */
	im = imaging.Fit(im, max_w, max_h, imaging.Lanczos)

	/* Re-encode it as a PNG */
	buf := &bytes.Buffer{}
	err = imaging.Encode(buf, im, imaging.PNG)
	if err != nil {
		return
	}

	bits = buf.Bytes()

	return

}

// Rand_number returns a random number.
//
// The golang random is used, seeding it with a nano second of the current timestamp.
//
// The number is restricted by the maximum number provided as a parameter.
//
// Callers using this should not expect perfectly cryptographically secure numbers.
func Rand_number(max int) int {
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	return r1.Intn(max)
}

// ToUTF8 converts a string from IOS8859_1 to UTF-8.
//
// This is primarily useful for copy&pasted text from Word documents.
// as otherwise the backticks are all magic.
//
// The input is a ISO8859_1 based string.
// Output is a standard Golang string which is UTF-8 based.
func ToUTF8(iso8859_1_buf []byte) string {
	buf := make([]rune, len(iso8859_1_buf))
	for i, b := range iso8859_1_buf {
		buf[i] = rune(b)
	}
	return string(buf)
}

// CopyFile duplicates a file from one location to another
//
// It overwrites files in the destination when they exist there.
//
// Permissions are copied from the source file to the destination file.
//
// The verbose option can be used to let it note which file it copied.
func CopyFile(ctx PfCtx, verbose bool, source string, dest string) (err error) {
	srcf, err := os.Open(source)
	if err != nil {
		return err
	}

	defer srcf.Close()

	dstf, err := os.Create(dest)

	if err != nil {
		return err
	}

	defer dstf.Close()

	_, err = io.Copy(dstf, srcf)
	if err != nil {
		return
	}

	src, err := os.Stat(source)
	if err != nil {
		err = os.Chmod(dest, src.Mode())

	}

	if verbose {
		ctx.OutLn("Copied File %s -> %s", source, dest)
	}

	return
}

// CopyDir recursively duplicates a directory.
//
// It recursively walks the source directory replicating it into
// the target directory.
//
// Files/directories starting with a '.' (typically used for 'hidden' files)
// are skipped from the copying process. Thus allowing .gitignore files
// to exist in the directory without being exposed to the destination directory.
//
// The context is used for outputting details about the copying process.
// The verbose option can be used for making the output a bit more verbose
// detailing primarily which directory it is copying and which files and
// directories are being ignored while copying.
//
// Logically the source file must exist and the destination must be writeable.
//
// Permissions for directories and files are copied to the destination.
//
// Any encountered error will break off the copy, leaving in
// the destination the progress made till that point.
func CopyDir(ctx PfCtx, verbose bool, source string, dest string) (err error) {
	if verbose {
		ctx.OutLn("Copying Directory %s -> %s", source, dest)
	}

	/* Get properties of source directory */
	sourceinfo, err := os.Stat(source)
	if err != nil {
		return err
	}

	/* Create destination directory (may already exist) */
	err = os.MkdirAll(dest, sourceinfo.Mode())
	if err != nil && err != os.ErrExist {
		return err
	}

	dir, err := os.Open(source)
	if err != nil {
		return err
	}

	objs, err := dir.Readdir(-1)

	if err != nil {
		return err
	}

	for _, obj := range objs {
		n := obj.Name()

		/* Ignore names that are empty */
		if len(n) == 0 {
			continue
		}

		/* The source and destination filenames */
		srcfptr := source + "/" + n
		dstfptr := dest + "/" + n

		/* Ignore names that begin with a dot (.) */
		if n[0] == '.' {
			if verbose {
				ctx.OutLn("Ignoring %q", srcfptr)
			}
			continue
		}

		if obj.IsDir() {
			/* Copy sub-directories recursively */
			err = CopyDir(ctx, verbose, srcfptr, dstfptr)
			if err != nil {
				return
			}
		} else {
			/* File Copies */
			err = CopyFile(ctx, verbose, srcfptr, dstfptr)
			if err != nil {
				return
			}
		}

	}

	return
}

// ThisFunc returns the name of the current function.
//
// This is primarily useful in combination with the TrackTime function.
//
// A typical usage:
// ```
// defer pf.TrackTime(pf.TrackStart(), pf.ThisFunc()+":Time Check")
// ```
// This causes a timer to start, noting the function name in the final report.
// When the function returns the time spent since the above will be reported.
func ThisFunc() string {
	pc := make([]uintptr, 10)
	runtime.Callers(2, pc)
	f := runtime.FuncForPC(pc[0])
	return f.Name()
}

// TrackStart returns the current time.
//
// To be used in combo with TrackTime().
func TrackStart() time.Time {
	return time.Now()
}

// TrackTime returns and logs the difference between the start (TrackStart) and end of the time.
func TrackTime(start time.Time, name string) (elapsed time.Duration) {
	elapsed = time.Since(start)
	DbgA(1, "%s took %s", name, elapsed)
	return
}

// Fmt_Time formats a time in standard time output format or returns 'never' when the time is zero.
func Fmt_Time(t time.Time) string {
	if t.IsZero() {
		return "never"
	}

	return t.Format(Config.TimeFormat)
}

// ErrIsDisconnect returns true when the error is a disconnection error.
func ErrIsDisconnect(err error) bool {
	neterr, ok := err.(net.Error)

	if ok && !neterr.Temporary() || err == io.EOF {
		return true
	}

	return false
}

// URL_EnsureSlash ensures that a URL ends in a slash.
func URL_EnsureSlash(url string) string {
	if len(url) == 0 || url[len(url)-1] != '/' {
		url += "/"
	}

	return url
}

// URL_Append append two parts of a URL together, adding a '/' in the middle where needed.
func URL_Append(url1 string, url2 string) (url string) {
	url1 = strings.TrimSpace(url1)
	url2 = strings.TrimSpace(url2)

	l1 := len(url1)
	l2 := len(url2)

	if l1 > 0 && url1[l1-1] == '/' {
		if l2 > 0 && url2[0] == '/' {
			/* Both have a '/' */
			url = url1 + url2[1:]
		} else {
			/* 1 has, 2 not */
			url = url1 + url2
		}
	} else {
		if l2 > 0 && url2[0] == '/' {
			/* 1 not, 2 has */
			url = url1 + url2
		} else {
			/* Neither have a '/' */
			url = url1 + "/" + url2
		}
	}

	return
}
